{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#whats-open-api","title":"What's Open API?","text":"<p>Open API is part of Spotware cTrader package, it allows cTrader users to develop trading applications by using their programming language of choice and its free for all cTrader users.</p>"},{"location":"#whats-openapinet","title":"What's OpenAPI.NET?","text":"<p>OpenAPI.NET is a .NET library for interacting with cTrader Open API, it makes Open API usage easier and allows you to focus on your project instead of spending time to figuring out how to compile Google Protobuf message files or how to send/receive API messages.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install OpenAPI.Net from Nuget on your .NET project, to install it run the following command on Nuget package manager console:</p> <pre><code>Install-Package Spotware.OpenAPI.Net\n</code></pre> <p>Or search for Spotware.OpenAPI.Net on Visual Studio Nuget package manager UI.</p>"},{"location":"authentication/","title":"Authentication","text":""},{"location":"authentication/#api-application","title":"API Application","text":"<p>To use Spotware Open API you have to first create an open API application, send an activation request to Spotware for your application, and once it got activated you can start using the API through your application.</p> <p>To create an Open API application go to: openapi.ctrader.com</p>"},{"location":"authentication/#getting-auth-code","title":"Getting Auth Code","text":"<p>After Spotware activated your API application, you can start using it, the first step is to get an authentication code from user, to do that via OpenAPI.NET you can use the code below to get authentication URL:</p> <p>First add these usings:</p> <pre><code>    using OpenAPI.Net;\n    using OpenAPI.Net.Auth;\n    using OpenAPI.Net.Helpers;\n</code></pre> <p>Then:</p> <pre><code>    // The classes used in this code snippet are located at OpenAPI.Net.Auth\n    // Your API application ID\n    var appId = \"\";\n    // Your API application secret\n    var appSecret = \"\"; \n    // One of your API applications redirect URI that you want to redirect user\n    var redirectUrl = \"\";\n    _app = new App(appId, appSecret, redirectUrl); \n    // The scope of authentication token (Trading or Accounts), Trading is default\n    var authUri = _app.GetAuthUri(scope: Scope.Trading);\n    // authUri is the authentication URI, open it on browser\n    System.Diagnostics.Process.Start(\"explorer.exe\", $\"\\\"{authUri}\\\"\");\n</code></pre> <p>When user opens the authentication URI on browser he has to enter his cTrader ID credentials and then select the trading accounts he want to authorize your API application to use, after that he will be redirected to your provided Redirect URL and the authentication code will be appended to the redirect URL as a parameter:</p> <pre><code>http://api.algodeveloper.com/redirects/?code=20df253b58df60a4e09f10b45e2ec11dbc0ccc565326d5706a8ea\n</code></pre> <p>As you can see \"http://api.algodeveloper.com/redirects/\" is my redirect URI and \"20df253b58df60a4e09f10b45e2ec11dbc0ccc565326d5706a8ea\" is the authentication code.</p> <p>To extract the authentication code from redirect URL you can use the AuthCode class.</p>"},{"location":"authentication/#generating-access-token","title":"Generating Access Token","text":"<p>After you got the user authentication code, you can generate an access token, you have to do it instantly otherwise authentication code will expire after one minute.</p> <p>To generate an access token via OpenAPI.NET use the following code:</p> <pre><code>    // The classes used in this code snippet are located at OpenAPI.Net.Auth\n    // Use TokenFactory to get the token\n    var token = await TokenFactory.GetToken(authCode, app);\n</code></pre> <p>Now you have a token object, it has these properties:</p> <ul> <li>AccessToken: This is the access token, you will use it on your API calls</li> <li>RefreshToken: This is the token that you will use to refresh your access token after it expired, refresh token never expires</li> <li>ExpiresIn: The expiry time of your access token</li> <li>TokenType: Type of access token</li> <li>ErrorCode: The error code, if access token is null then use this property to find the cause</li> <li>ErrorDescription: The text description of error code</li> </ul> <p>To refresh access token send a ProtoOARefreshTokenReq to OpenClient (API client) with your refresh token.</p> <p>Now you have an access token, you can use it to take the list of user authenticated trading accounts and then execute trading operations on those accounts or get accounts historical data, for that you have to use OpenClient.</p>"},{"location":"calculating-symbol-tick-value/","title":"Calculating Symbol Tick/Pip Value","text":"<p>When it comes to using Open API for trading or developing trading applications the most difficult part is calculating the symbols tick value, without a symbol tick value you can't calculate account equity, used margin, or size your position based on your account balance/equity.</p> <p>OpenAPI.NET makes symbol tick/Pip value calculation as simple as possible by providing a set of helper methods that you can use to calculate not just tick/Pip value also other properties of symbols like tick/Pip size.</p> <p>We also have a WPF Sample application that has all the necessary code for calculating symbols tick/Pip value and other account statistics like equity, free margin, used margin, margin level, net profit, and gross profit.</p> <p>To calculate a symbol tick value:</p> <ul> <li> <p>Get all account assets by sending a ProtoOAAssetListReq request, store the assets inside a collection.</p> </li> <li> <p>You have to get all available symbols of a trading account by sending a ProtoOASymbolsListReq, then get all those symbols full entities by sending a ProtoOASymbolByIdReq, add all symbol IDs to the request SymbolId collection, store all symbol entities inside a collection.</p> </li> <li> <p>Subscribe to ProtoOASpotEvent of your API client:</p> </li> </ul> <pre><code>client.OfType&lt;ProtoOASpotEvent&gt;().Subscribe(OnSpotEvent);\n</code></pre> <p>OnSpotEvent will be the callback method that will be called whenever a symbol bid/ask changes, this method must have a ProtoOASpotEvent parameter.</p> <ul> <li> <p>Subscribe to all symbols live quotes by sending a ProtoOASubscribeSpotsReq, add all symbols IDs to the request SymbolId collection.</p> </li> <li> <p>Now whenever a symbol bid/ask changes you will receive a ProtoOASpotEvent and your OnSpotEvent method will be called.</p> </li> <li> <p>Inside your OnSpotEvent you have to find the upcoming tick data symbol entity, the ProtoOASpotEvent has a SymbolId property that you can use.</p> </li> <li> <p>After you found the symbol entity that the ProtoOASpotEvent belongs to, you have to calculate its Bid/Ask:</p> </li> </ul> <pre><code>using OpenAPI.Net.Helpers;\n// spotEvent is ProtoOASpotEvent\nif (spotEvent.HasBid) bid = symbol.GetPriceFromRelative((long)spotEvent.Bid);\nif (spotEvent.HasAsk) ask = symbol.GetPriceFromRelative((long)spotEvent.Ask);\n</code></pre> <p>The GetPriceFromRelative method is part of SymbolExtensions class, its an extension method of ProtoOASymbol, to access it you have to add the \"OpenAPI.Net.Helpers\" using.</p> <ul> <li>Now we have the symbol latest bid/ask price, to calculate the tick value:</li> </ul> <p><pre><code>using OpenAPI.Net.Helpers;\n\ndouble symbolTickValue = 0;\n\nif (symbolQuoteAsset.AssetId == accountDepositAsset.AssetId)\n{\n    symbolTickValue = symbol.GetTickValue(symbolQuoteAsset, accountDepositAsset, null, default);\n}\nelse\n{\n    var conversionSymbol = Symbols.FirstOrDefault(iSymbol =&gt; (iSymbol.BaseAssetId == symbolQuoteAsset.AssetId\n        || iSymbol.QuoteAssetId == symbolQuoteAsset.AssetId)\n        &amp;&amp; (iSymbol.BaseAssetId == accountDepositAsset.AssetId\n        || iSymbol.QuoteAssetId == accountDepositAsset.AssetId));\n\n    if (conversionSymbol is not null &amp;&amp; conversionSymbol.Bid is not 0)\n    {\n        var conversionSymbolBaseAsset = accountAssets.First(iAsset =&gt; iAsset.AssetId == conversionSymbol.BaseAssetId);\n\n        symbolTickValue = symbol.GetTickValue(symbolQuoteAsset, accountDepositAsset, conversionSymbolBaseAsset, conversionSymbol.Bid);\n    }\n}\n</code></pre> When a symbol quote asset/currency is same as your trading account deposit currency then its tick value is equal to the symbol tick size, that's why in above code snippet we check if its equal then we don't look for conversion symbol and we pass null and default (0) for conversion symbol base asset/currency and its current price.</p> <p>If its not then we have to convert the symbol price to account deposit currency, to do that we first iterate over all symbol entities, we need a symbol that its quote asset be same as symbol quote asset and its base or quote asset be same as account deposit asset/currency.</p> <p>Once we found the conversion symbol we then get its base asset from account assets collection and then we pass all data to the symbol GetTickValue extension method, this method is also part of SymbolExtensions class which is in \"OpenAPI.Net.Helpers\" name space.</p> <p>For a complete example please check our WPF Sample application.</p> <p>Also check our Blazor web assembly sample which is deployed in Github pages.</p>"},{"location":"compiling-proto-files/","title":"Compiling Proto Files","text":"<p>If you are using this library it comes with compiled proto files of Spotware Open API and we do our best to keep the files update, in case there was a new version of proto files available and we weren't updated the files in library you can clone the library and compile the new proto files, then replace the library proto files with your compiled ones, the message files are located at Protobuf project inside Messages directory.</p> <p>For compiling the proto files there is a guide available on Spotware Open API documentation but that is out dated and if you compile the files by following their instruction you will endup with Protobuf 2.0 which is old version and not supported anymore by Google, the new Protobuf 3 compiler can compile the old version files, Open API uses 2.0 but you can use the new version compiler and benifit from all the new features of version 3.</p> <p>If you use the old version compiled files then you can't use .NET Core, because the Google Protobuf 2 .NET library is only available for .NET framework.</p> <p>We recommend you to use our compiling instruction instead of Spotware documentation instruction, this instruction is for Windows and you can follow the Google standard instruction on Protobuf documentation if you are using Linux.</p> <ul> <li>Download the proto files from Spotware provided link/repo</li> <li>Download the Google Protobuf latest version from here</li> <li>Extract the Google Protobuf, there will be a \"bin\" folder, copy the \".proto\" files there</li> <li>Open \"CMD\", go to bin folder location, and type:  <pre><code>protoc --csharp_out=. ./proto_file_name.proto\n</code></pre> Instead of \"proto_file_name.proto\" you have to provide each of the proto files names, you have to execute this command for each proto file.</li> </ul> <p>After executing the command there will be a \".cs\" file for the proto file, you can use those files instead of library default message files.</p> <p>Don't forget to update the library Google Protobuf Nuget package to the version that you used for compiling the proto files, otherwise you will see lots of errors and you will not be able to build the project.</p>"},{"location":"open-client/","title":"Open Client","text":""},{"location":"open-client/#creatingconnecting-client","title":"Creating/Connecting Client","text":"<p>The open client is the object that you will use to send/receive messages to API.</p> <p>First add these usings:</p> <pre><code>    using OpenAPI.Net;\n    using OpenAPI.Net.Auth;\n    using OpenAPI.Net.Helpers;\n    using System.Reactive.Linq;\n    using System.Linq;\n    using Google.Protobuf;\n</code></pre> <p>Then:</p> <pre><code>    // Mode can be either live or demo\n    // If you want to access and work with live\n    // trading accounts then use live otherwise use demo\n    var host = ApiInfo.GetHost(mode);\n    // You can set the maximum number of requests clients should send per second by using maxRequestPerSecond parameter (default: 40)\n    // If you want to use web socket instead of TCP socket pass true for useWebSocket parameter of constructor\n    // web socket allows you to use the Open API on static server-less sites like Blazor WASM environment \n    var client = new OpenClient(host, ApiInfo.Port, TimeSpan.FromSeconds(10));\n</code></pre> <p>The first parameter of OpenClient is host, this is the API host URL based on your selected mode, the second parameter is API host port, and the third one is a time span that will be used as interval for sending heartbeats to API server.</p> <p>Use 10 or 15 seconds for sending heartbeats.</p> <p>You don't have to send heartbeat to server manually, the client will send that and it will keep its connection alive</p> <p>After you created the client you have to call its Connect method:</p> <pre><code>    await client.Connect();\n</code></pre> <p>If connection fails it will throw a ConnectionException, check the inner exception to get the actual exception that was thrown.</p> <p>If you call a disposed client Connect method it will throw a ObjectDisposedException.</p> <p>Now client is connected to API server and you can send/receive messages.</p> <p>The OpenClient (IOpenClient) implements IDisposable, so you can use it on a C# \"using\" block like file streams.</p> <p>Once you finished your work with client don't forget to dispose it or if you just need it for sending/receiving few messages you can use it inside a using block:</p> <pre><code>    using (var client = new OpenClient(host, ApiInfo.Port, TimeSpan.FromSeconds(10))\n    {\n        await client.Connect();\n\n        // Send message or subscribe to responses here\n    }\n</code></pre> <p>Or you can:</p> <pre><code>    using var client = new OpenClient(host, ApiInfo.Port, TimeSpan.FromSeconds(10));\n    await client.Connect();\n</code></pre> <p>The OpenClient class has some useful public properties you can use to check the state of client.</p>"},{"location":"open-client/#sending-messages","title":"Sending Messages","text":"<p>You can send all of the Open API supported messages easily via your OpenClient object, just create the message object and send it by calling client \"SendMessage\" method:</p> <pre><code>    // The first message you must send\n    var applicationAuthReq = new ProtoOAApplicationAuthReq\n    {\n        ClientId = \"\",\n        ClientSecret = \"\",\n    };\n\n    await _client.SendMessage(applicationAuthReq,\n        ProtoOAPayloadType.ProtoOaApplicationAuthReq,\n        \"This is client message ID and its optional\");\n</code></pre> <p>You have to provide the message payload type, you can use \"ProtoOAPayloadType\" or \"ProtoPayloadType\" enumeration types to get the message payload type based on your message type.</p> <p>The last parameter of \"SendMessage\" method is client message ID, you don't have to pass it as the client message ID is optional, this message will be returned back on response.</p> <p>All open API messages have their own classes, just create an object of message class and send it.</p> <p>There are other SendMessage method overloads that you can use, all send message methods put your message on the messages queue channel.</p> <p>To send a message instantly you can use the SendMessageInstant method. </p>"},{"location":"open-client/#receiving-messages","title":"Receiving Messages","text":"<p>The OpenClient (IOpenClient) class implements the RX \"IObservable\" interface, the \"IMessage\" is the base class of all Google Protobuf messages, this allows you to easily subscribe to any message type you want to receive: <pre><code>    // Here I'm filtering out the ProtoHeartbeatEvent and subscribing\n    // to all other message types\n    // The OnError will be called if something went wrong\n    var disposable = client.Where(iMessage =&gt;  iMessage is not ProtoHeartbeatEvent)\n        .Subscribe(OnMessageReceived, OnError);\n</code></pre> <p>A basic understanding of RX observable streams will help you a lot.</p> <p>After you subscribed to a message it will return back an IDisposable object, to unsubscribe you have to dispose the returned IDisposable object.</p> <p>To subscribe for an specific message type use Linq OfType extension method:</p> <pre><code>    // Here I'm subscribing to only ProtoOAErrorRes\n    var disposable = client.OfType&lt;ProtoOAErrorRes&gt;().Subscribe(OnError);\n</code></pre> <p>You can use any of the Open API response or event messages to subscribe like above code snippet.</p> <p>If you want to receive a message with a client message ID (clientMsgId) then you have to subscribe to \"ProtoMessage\" and then use the MessageFactory class to get the actual message:</p> <pre><code>    var disposable = client.OfType&lt;ProtoMessage&gt;().Subscribe(OnProtoMessage);\n\n    private void OnProtoMessage(ProtoMessage protoMessage)\n    {\n        var clientMsgId = protoMessage.ClientMsgId;\n        // Message factory can return null\n        var message = MessageFactory.GetMessage(protoMessage);\n    }\n</code></pre> <p>Client only stream a ProtoMessage if its ClientMsgId is set or it couldn't parse the actual message, otherwise it will not stream it.</p>"},{"location":"open-client/#handling-exceptions","title":"Handling Exceptions","text":"<p>If something went wrong or client lost connection to API you can get the thrown exception by subscribing to client stream OnError:</p> <pre><code>    // Here I'm subscribing to only ProtoOAErrorRes\n    var disposable = client.Subscribe(_ =&gt; {}, OnError);\n</code></pre> <p>Now client will call and pass the exception to your OnError, also if your OnError method got triggered it means the client stream is terminated, based on RX guidelines you have to stop interacting with it, you don't have to dispose the client after it got terminated because the client will dispose itself on termination.</p> <p>If you try to dispose a terminated client nothing will happen.</p> <p>Client most probably will throw one of these exception types:</p> <ul> <li>ReceiveException: This exception type will be thrown if something went wrong while receiving data</li> <li>ObserverException: This exception will be thrown if something went wrong during an observer (subscriber) OnNext method call, you can get the observer object via its Observer property</li> </ul> <p>Check the above exceptions \"InnerException\" property to get the actual exception.</p> <p>During call to any of client \"SendMessage\" methods you can expect one of these exceptions:</p> <ul> <li>SendException: This exception will be thrown if something went wrong while sending data</li> <li>ObjectDisposedException: If you call send message of a disposed client then it will throw this exception</li> </ul>"},{"location":"open-client/#disposing-client","title":"Disposing Client","text":"<p>As mentioned the client object implements IDisposable interface, so you must dispose it after finishing your work.</p> <p>To avoid calling dispose method several times you can check the client IsDisposed property and calling dispose method several times will not cause any issue.</p> <p>If a client got terminated by an exception and it called the OnError of observers then it will dispose itself and you don't have to call the dispose method inside your OnError handler.</p> <p>If the client is disposed without termination then it will call the observers OnCompleted handler.</p> <p>If you got a ConnectionException during the call on client Connect method then the client is already disposed, you don't have to call it's dispose method and you can't use that client instance anymore.</p>"}]}